## Введение в ООП

### Недостатки ООП

Упрощенное использование объектов закономерно ведет к усложнению их внутренней структуры.

### Отличие класса от объекта

**Объект** — это некоторая структура, которая хранится в памяти, имеет некоторое состояние, 
умеет его изменять, умеет взаимодействовать с окружающим миром, с другими объектами при помощи методов. 
Суть - инстанс класса.

**Класс** — это способ описания объекта. В нем описано, каким образом создается некоторый объект, 
какая у него будет функциональность. Суть класс в Python.
 
**Объект-класс** — это такое понятие, характерное для некоторых языков программирования. 
Это такой объект, который и хранит в себе информацию о способе создания и возможностях некоторого другого объекта. 
Кроме того, он умеет самостоятельно порождать другие объекты. Пример: мета-класс в Python.

### Отличие интерфейса класса от реализации

**Интерфейс (абстракция)** - лицо класса. Это совокупность всех способов доступа и взаимодейтсвия с некоторым объектом.
Интерфейс объекта состоит из публичных методов и атрибутов, доставшихся ему от его родительских классов, 
а также из его собственных публичных полей.

**Реализация** - внутренности класса. Она описывает то, как именно устроен объект. 
Каким образом он будет решать поставленную перед ним задачу. 

### Парадигмы ООП

* **Полиморфизм** - позволяет использовать один и тот же код для различных объектов, имеющих один и тот же интерфейс, 
но обладающих различной реализацией. Блягодаря полиморфизму можно работать с классом-потомком точно так же, 
как и с родительским классом: 
```python
class Parent:

    def some_method(self):
        print("This is Parent object")


class Child1(Parent):

    def some_method(self):
        print("This is Child1 object")


class Child2(Parent):

    def some_method(self):
        print("This is Child2 object")


def who_am_i(obj):
    obj.some_method()


p = Parent()
c1 = Child1()
c2 = Child2()

who_am_i(p)
who_am_i(c1)
who_am_i(c2)
print()

```

* **Инкапсуляция** - возможность защитить некоторые данные от несанкционированного доступа. 
Она позволяет упаковать все данные и функции в некоторый единый компонент.

**Приватный метод (он же private)** - такой метод (свойство), доступ к которому можно получить только 
из того же класса (или объекта того же класса). В Python для того чтобы сделать метод или атрибут приватным
нужно добавить к его имени два символа подчеркивания в начало

**Защищенный метод (он же protected)** - такой метод (свойство), доступ к которому можно получить только из 
того же класса (или объекта того же класса) и из его наследников. Полностью protected методов в Python нет, 
но есть договоренность, что методы и атрибуты, имя которых начинается с одного символа нижнего подчеркивания
по сути являются protected методами (атрибутами) 

**Публичный метод (он же public)**  - такой метод (свойство), доступ к которому можно получить откуда угодно - извне
 определенного класса, из объекта определенного класса, из наследников.

* **Наследование** - позволяет строить сложные иерархии классов. Класс-потомок наследует все публичные методы 
и атрибуты класса-родителя.

```python
class A:

    def some_function(self):
        print("First function")
        
    def other_function(self):
        print("Second function")


class B:
    
    def method_in_B(self):
        print("Third function")


class C(A):
    
    def other_function(self):
        print("Replaced function")


class D(B, C):

    pass
  

# Посмотрим все атрибуты класса, не являющиеся служебными
print("A:\t", list(filter(lambda x: "__" not in x, dir(A))))
print("B:\t", list(filter(lambda x: "__" not in x, dir(B))))
print("C(A):\t", list(filter(lambda x: "__" not in x, dir(C))))
print("D(B,C):\t", list(filter(lambda x: "__" not in x, dir(D))))
print()

# Посмотрим на реализацию функцй в D
d = D()
d.method_in_B()
d.some_function()
d.other_function()
print()
```

### SOLID принципы ООП

**Принцип единственной ответственности (The Single Responsibility Principle):** у каждого объекта должна быть только одна ответственность. 
Все поведение этого объекта должно быть направлено на обеспечение этой ответственности и никаких других.

**Принцип открытости/закрытости (The Open Closed Principle):** классы должны быть открыты для расширения, 
но закрыты для изменения. Этот принцип является важным, потому что внесение изменений в существующие компоненты 
системы может также привести к непредвиденным изменения в работе самой этой системы. 
Однако поведение существующих объектов при необходимости можно расширить при помощи создания новых сущностей.

**Принцип подстановки Барбары Лисков (The Liskov Substitution Principle):** 
функции, которые используют базовый тип должны иметь возможность использовать его подтипы не зная об этом.

**Принцип разделения интерфейса (The Interface Segregation Principle):**
 клиенты не должны зависеть от методов, которые они не используют.
 
**Принцип инверсии зависимостей (The Dependency Inversion Principle):**
 
* Модули верхних уровней не должны зависеть от модулей нижних уровней. 
Оба типа модулей должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
 
 
### UML-нотация

* **UML(Unified Modeling Language)** - унифицированный язык моделирования

* UML - графический язык, а не язык программирования. 
Позволяет описывать структуру программ, систем, бизнес-процессов

**Основные элементы UML**
* Фигура 
* Значок 
* Рамка 
* Текст 
* Линия

### Рефакторинг кода

**Рефакторинг или переработка кода** — это процесс преобразования внутренней структуры кода, 
который призван облегчить его понимание. 

Понятие рефакторинга иногда путают с понятием оптимизации или реинжиниринга.

**Оптимизация** - процесс переработки внутренней структуры кода с целью увеличения его производительности. 
При оптимизации читаемость кода может в том числе и снизиться

**Реинжениринг** - процесс полного переписывания некоторого блока кода. 
При реинжиниринге может измениться и работа некотрого блока кода

### Когда нужен рефакторинг?
* Сложная архитеркутра системы
* Использование объектов, затрудняющих понимание системы
* Упрощение схем наследования
* Преобразование процедурного кода к объектно-ориентированному

